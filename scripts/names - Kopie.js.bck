// ===== GLOBALER DATEN-MANAGER =====
class NamesDataManager {
  constructor() {
    this.nameData = new Map();
    this.availableLanguages = new Set();
    this.availableSpecies = new Set();
    this.availableCategories = new Set();
    this.grammarRules = new Map();
    this.languageConfig = null;
    this.speciesConfig = null;
    this.isLoading = false;
    this.isLoaded = false;
    this.loadingPromise = null;
    this.nameCategories = {
      'firstnames': ['male', 'female', 'nonbinary'],
      'surnames': ['surnames'],
      'titles': ['titles'],
      'nicknames': ['nicknames'],
      'settlements': ['settlements']
    };
  }

  // Startet das Laden der Daten im Hintergrund
  async initializeData() {
    if (this.isLoaded || this.isLoading) {
      return this.loadingPromise;
    }

    this.isLoading = true;
    this._log('console.background-loading-started');

    this.loadingPromise = this._loadAllData();
    
    try {
      await this.loadingPromise;
      this.isLoaded = true;
      this._log('console.background-loading-completed');
    } catch (error) {
      this._log('console.background-loading-failed', null, error);
    } finally {
      this.isLoading = false;
    }

    return this.loadingPromise;
  }

  async _loadAllData() {
    await this.loadConfigs();
    await this.loadNameData();
  }

  async loadConfigs() {
    try {
      const langResponse = await fetch("modules/names/lang/_config.json");
      if (langResponse.ok) {
        this.languageConfig = await langResponse.json();
        this._log('console.grammar-loaded', { key: 'language config' });
      }
    } catch (error) {
      this._log('console.index-error', null, error);
    }

    try {
      const speciesResponse = await fetch("modules/names/lang/_species-mapping.json");
      if (speciesResponse.ok) {
        this.speciesConfig = await speciesResponse.json();
        this._log('console.grammar-loaded', { key: 'species config' });
      }
    } catch (error) {
      this._log('console.index-error', null, error);
    }
  }

  async loadNameData() {
    this._log('console.loading-index');

    try {
      const indexResponse = await fetch("modules/names/data/index.json");
      if (!indexResponse.ok) {
        this._log('console.index-not-found');
        await this.loadFallbackData();
        return;
      }

      const indexData = await indexResponse.json();
      this._log('console.index-loaded', { count: indexData.files.length });

      const loadPromises = indexData.files
        .filter(file => file.enabled !== false)
        .map(file => this.loadDataFileFromIndex(file));

      await Promise.all(loadPromises);

    } catch (error) {
      this._log('console.index-error', null, error);
      await this.loadFallbackData();
    }

    this._log('console.available-languages', null, Array.from(this.availableLanguages));
    this._log('console.available-species', null, Array.from(this.availableSpecies));
    this._log('console.available-categories', null, Array.from(this.availableCategories));
  }

  async loadFallbackData() {
    const knownFiles = [
      { filename: 'de.human.male.json', language: 'de', species: 'human', category: 'male' },
      { filename: 'de.human.female.json', language: 'de', species: 'human', category: 'female' },
      { filename: 'de.human.surnames.json', language: 'de', species: 'human', category: 'surnames' },
      { filename: 'de.human.titles.json', language: 'de', species: 'human', category: 'titles' },
      { filename: 'de.human.nicknames.json', language: 'de', species: 'human', category: 'nicknames' },
      { filename: 'de.human.settlements.json', language: 'de', species: 'human', category: 'settlements' },
      { filename: 'de.elf.male.json', language: 'de', species: 'elf', category: 'male' }
    ];

    const loadPromises = knownFiles.map(file => this.loadDataFileFromIndex(file));
    await Promise.all(loadPromises);
  }

  async loadDataFileFromIndex(fileInfo) {
    try {
      const response = await fetch(`modules/names/data/${fileInfo.filename}`);
      if (!response.ok) {
        this._log('console.file-unavailable', { 
          filename: fileInfo.filename, 
          status: response.status 
        });
        return;
      }

      const data = await response.json();

      this.availableLanguages.add(fileInfo.language);
      this.availableSpecies.add(fileInfo.species);
      this.availableCategories.add(fileInfo.category);

      const key = `${fileInfo.language}.${fileInfo.species}.${fileInfo.category}`;
      this.nameData.set(key, data);

      if (data.grammar && fileInfo.category === 'titles') {
        const grammarKey = `${fileInfo.language}.${fileInfo.species}`;
        this.grammarRules.set(grammarKey, data.grammar);
        this._log('console.grammar-loaded', { key: grammarKey });
      }

      const entryCount = this._getDataEntryCount(data, fileInfo.category);
      this._log('console.file-loaded', { 
        filename: fileInfo.filename, 
        count: entryCount 
      });

    } catch (error) {
      this._log('console.file-failed', { 
        filename: fileInfo.filename, 
        error: error.message 
      });
    }
  }

  _getDataEntryCount(data, category) {
    if (category === 'titles' && data.titles) {
      return (data.titles.male?.length || 0) + (data.titles.female?.length || 0) + (data.titles.nonbinary?.length || 0);
    }
    if (category === 'nicknames' && data.names) {
      return (data.names.male?.length || 0) + (data.names.female?.length || 0) + (data.names.nonbinary?.length || 0);
    }
    return data.names?.length || data.settlements?.length || data.titles?.length || 0;
  }

  getLocalizedLanguages() {
    const languages = [];
    
    if (this.languageConfig) {
      for (const [code, config] of Object.entries(this.languageConfig.supportedLanguages)) {
        if (config.enabled && this.availableLanguages.has(code)) {
          languages.push({
            code: code,
            name: game.i18n.localize(config.name) || config.nativeName || code.toUpperCase()
          });
        }
      }
    } else {
      for (const lang of this.availableLanguages) {
        const locKey = `names.languages.${lang}`;
        languages.push({
          code: lang,
          name: game.i18n.localize(locKey) || lang.toUpperCase()
        });
      }
    }

    return languages.sort((a, b) => a.name.localeCompare(b.name));
  }

  getLocalizedSpecies() {
    const species = [];
    
    for (const spec of this.availableSpecies) {
      const locKey = `names.species.${spec}`;
      species.push({
        code: spec,
        name: game.i18n.localize(locKey) || spec.charAt(0).toUpperCase() + spec.slice(1)
      });
    }

    return species.sort((a, b) => a.name.localeCompare(b.name));
  }

  // Prüft ob Daten für eine bestimmte Kombination verfügbar sind
  hasData(language, species, category) {
    const key = `${language}.${species}.${category}`;
    return this.nameData.has(key);
  }

  // Lazy Loading für spezifische Daten
  async ensureDataLoaded(language, species, category) {
    const key = `${language}.${species}.${category}`;
    
    if (this.nameData.has(key)) {
      return true;
    }

    // Versuche die spezifische Datei zu laden
    const filename = `${language}.${species}.${category}.json`;
    const fileInfo = { filename, language, species, category };
    
    await this.loadDataFileFromIndex(fileInfo);
    return this.nameData.has(key);
  }

  _log(messageKey, params = null, error = null) {
    let message;
    
    try {
      message = params ? 
        game.i18n.format(`names.${messageKey}`, params) : 
        game.i18n.localize(`names.${messageKey}`);
    } catch (e) {
      message = messageKey;
    }

    const prefix = "Names Module: ";
    
    if (error) {
      console.warn(prefix + message, error);
    } else {
      console.log(prefix + message);
    }
  }
}

// Globale Instanz
let globalNamesData = null;

// Hilfsfunktion um sicherzustellen, dass globalNamesData existiert
function ensureGlobalNamesData() {
  if (!globalNamesData) {
    console.log("Names Module: Creating new NamesDataManager instance");
    globalNamesData = new NamesDataManager();
  }
  return globalNamesData;
}

// ===== NAMEN-GENERATOR APP =====
class NamesGeneratorApp extends Application {
  constructor(options = {}) {
    super(options);
    this.supportedGenders = ['male', 'female', 'nonbinary'];
  }

  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      id: "names-generator",
      title: game.i18n.localize("names.title"),
      template: "modules/names/templates/names.hbs",
      width: 450,
      height: 690,
      resizable: true,
      classes: ["names-module-app"]
    });
  }

  async getData() {
    // Stelle sicher, dass globalNamesData existiert
    ensureGlobalNamesData();
    
    // Warte auf die Daten, falls sie noch laden
    await globalNamesData.initializeData();

    return {
      languages: globalNamesData.getLocalizedLanguages(),
      species: globalNamesData.getLocalizedSpecies(),
      categories: Array.from(globalNamesData.availableCategories).sort(),
      isLoading: globalNamesData.isLoading,
      isLoaded: globalNamesData.isLoaded
    };
  }

  activateListeners(html) {
    super.activateListeners(html);

    html.find('#names-generate-btn').click(this._onGenerateName.bind(this));
    html.find('#names-copy-btn').click(this._onCopyName.bind(this));
    html.find('#names-clear-btn').click(this._onClearResult.bind(this));

    html.find('input[type="checkbox"]').change(this._onComponentChange.bind(this));
    html.find('select').change(this._onDropdownChange.bind(this));

    // Loading-Indikator aktualisieren
    if (globalNamesData.isLoading) {
      this._showLoadingState(html);
      this._waitForLoadingComplete(html);
    } else {
      this._updateUI(html);
    }
  }

  async _waitForLoadingComplete(html) {
    await globalNamesData.loadingPromise;
    
    // UI nach dem Laden aktualisieren
    html.find('.names-loading-indicator').hide();
    html.find('.names-module-form').show();
    this._updateUI(html);
    
    // Dropdown-Optionen neu aufbauen
    this.render(false);
  }

  _showLoadingState(html) {
    html.find('.names-module-form').hide();
    
    if (!html.find('.names-loading-indicator').length) {
      html.find('.window-content').prepend(`
        <div class="names-loading-indicator" style="text-align: center; padding: 50px;">
          <i class="fas fa-spinner fa-spin" style="font-size: 2em; color: #ff6400;"></i>
          <p style="margin-top: 15px;">${game.i18n.localize("names.loading-data") || "Lade Namen-Daten..."}</p>
        </div>
      `);
    }
  }

  _onComponentChange(event) {
    const form = event.currentTarget.closest('form');
    const checkboxes = form.querySelectorAll('input[type="checkbox"]:checked');
    const generateBtn = form.querySelector('#names-generate-btn');

    generateBtn.disabled = checkboxes.length === 0;
  }

  _onDropdownChange(event) {
    const $form = $(event.currentTarget).closest('form');
    this._updateUI($form);
  }

  _updateUI($form) {
    const language = $form.find('#names-language-select').val();
    const species = $form.find('#names-species-select').val();
    const category = $form.find('#names-category-select').val();

    this._updateCategoryOptions($form, language, species);
    this._toggleNameComponentsPanel($form, category);
    this._updateGenerateButtonState($form, category);
  }

  _updateCategoryOptions(html, language, species) {
    const categorySelect = html.find('#names-category-select');
    const currentValue = categorySelect.val();

    categorySelect.find('option:not(:first)').remove();

    if (language && species) {
      const availableCategories = new Set();

      for (const [key, data] of globalNamesData.nameData.entries()) {
        const [dataLang, dataSpecies, dataCategory] = key.split('.');
        if (dataLang === language && dataSpecies === species) {
          availableCategories.add(dataCategory);
        }
      }

      const localizedCategories = [];
      for (const category of availableCategories) {
        const locKey = `names.categories.${category}`;
        localizedCategories.push({
          code: category,
          name: game.i18n.localize(locKey) || category
        });
      }

      localizedCategories.sort((a, b) => a.name.localeCompare(b.name));

      for (const category of localizedCategories) {
        categorySelect.append(`<option value="${category.code}">${category.name}</option>`);
      }

      if (currentValue && availableCategories.has(currentValue)) {
        categorySelect.val(currentValue);
      }
    }
  }

  _toggleNameComponentsPanel(html, category) {
    const panel = html.find('.names-module-components-section');
    const formatGroup = html.find('.names-module-format-group');

    if (this.supportedGenders.includes(category)) {
      panel.show();
      formatGroup.show();
    } else {
      panel.hide();
      formatGroup.hide();
    }
  }

  _updateGenerateButtonState(html, category) {
    const generateBtn = html.find('#names-generate-btn');
    const language = html.find('#names-language-select').val();
    const species = html.find('#names-species-select').val();

    if (this.supportedGenders.includes(category)) {
      const checkboxes = html.find('input[type="checkbox"]:checked');
      generateBtn.prop('disabled', !language || !species || !category || checkboxes.length === 0);
    } else {
      generateBtn.prop('disabled', !language || !species || !category);
    }
  }

  async _onGenerateName(event) {
    event.preventDefault();

    const form = event.currentTarget.closest('form');
    const formData = new FormData(form);

    const language = formData.get('names-language');
    const species = formData.get('names-species');
    const category = formData.get('names-category');
    const nameFormat = formData.get('names-format') || '{firstname} {nickname} {surname}, {title}';
    const count = parseInt(formData.get('names-count')) || 1;

    if (!language || !species || !category) {
      ui.notifications.warn(game.i18n.localize("names.select-all"));
      return;
    }

    // Stelle sicher, dass die benötigten Daten geladen sind
    const hasData = await globalNamesData.ensureDataLoaded(language, species, category);
    if (!hasData) {
      ui.notifications.error(game.i18n.localize("names.data-not-available"));
      return;
    }

    try {
      const results = [];

      for (let i = 0; i < count; i++) {
        let generatedName;

        if (this.supportedGenders.includes(category)) {
          const selectedComponents = [];
          if (formData.get('names-include-firstname')) selectedComponents.push('firstname');
          if (formData.get('names-include-surname')) selectedComponents.push('surname');
          if (formData.get('names-include-title')) selectedComponents.push('title');
          if (formData.get('names-include-nickname')) selectedComponents.push('nickname');

          if (selectedComponents.length === 0) {
            ui.notifications.warn(game.i18n.localize("names.select-components"));
            return;
          }

          generatedName = await this._generateFormattedName(language, species, category, selectedComponents, nameFormat);
        } else {
          generatedName = await this._generateSimpleName(language, species, category);
        }

        if (generatedName) {
          results.push(generatedName);
        }
      }

      if (results.length === 0) {
        throw new Error(game.i18n.localize("names.no-names-generated"));
      }

      const resultDiv = form.querySelector('#names-result-display');
      const authorCredits = this._collectAuthorCredits(language, species, [category]);

      let resultsHtml = results.map(name =>
        `<div class="names-module-generated-name">${name}</div>`
      ).join('');

      resultDiv.innerHTML = resultsHtml + authorCredits;

      form.querySelector('#names-copy-btn').disabled = false;
      form.querySelector('#names-clear-btn').disabled = false;

    } catch (error) {
      const errorMsg = game.i18n.format("names.generation-error", { error: error.message });
      ui.notifications.error(errorMsg);
    }
  }

  async _generateSimpleName(language, species, category) {
    if (category === 'settlements') {
      const settlementData = globalNamesData.nameData.get(`${language}.${species}.settlements`);
      if (!settlementData?.settlements) {
        throw new Error(`Keine Siedlungsdaten für ${language}.${species}`);
      }
      const settlements = settlementData.settlements;
      const settlement = settlements[Math.floor(Math.random() * settlements.length)];
      return settlement.name || settlement;
    } else {
      return this._getRandomFromData(language, species, category);
    }
  }

  async _generateFormattedName(language, species, gender, components, nameFormat) {
    let selectedSettlement = null;

    if (components.includes('title')) {
      const settlementData = globalNamesData.nameData.get(`${language}.${species}.settlements`);
      if (settlementData?.settlements) {
        const settlements = settlementData.settlements;
        selectedSettlement = settlements[Math.floor(Math.random() * settlements.length)];
      }
    }

    const nameComponents = {};
    for (const component of components) {
      try {
        let part = await this._generateNameComponent(language, species, gender, component, selectedSettlement);
        if (part) {
          nameComponents[component] = part;
        }
      } catch (error) {
        globalNamesData._log('console.component-generation-failed', { component }, error);
      }
    }

    if (Object.keys(nameComponents).length === 0) {
      throw new Error(game.i18n.localize("names.no-names-generated"));
    }

    return this._formatName(nameFormat, nameComponents);
  }

  _formatName(format, components) {
    let result = format;

    const placeholders = {
      '{firstname}': components.firstname || '',
      '{surname}': components.surname || '',
      '{title}': components.title || '',
      '{nickname}': components.nickname || ''
    };

    for (const [placeholder, value] of Object.entries(placeholders)) {
      result = result.replace(new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), value);
    }

    result = result
      .replace(/\s+/g, ' ')
      .replace(/\s*,\s*,/g, ',')
      .replace(/^[,\s]+|[,\s]+$/g, '')
      .replace(/,\s*$/g, '')
      .replace(/^\s*,/g, '')
      .replace(/\s+,/g, ',')
      .replace(/,\s*/g, ', ')
      .trim();

    return result;
  }

  async _generateNameComponent(language, species, gender, component, settlement) {
    switch (component) {
      case 'firstname':
        return this._getRandomFromData(language, species, gender);

      case 'surname':
        return this._getRandomFromData(language, species, 'surnames');

      case 'title':
        return this._generateTitle(language, species, gender, settlement);

      case 'nickname':
        const nickname = this._getRandomFromGenderedData(language, species, 'nicknames', gender);
        return nickname ? `"${nickname}"` : null;

      default:
        return null;
    }
  }

  _generateTitle(language, species, gender, settlement) {
    const titleData = globalNamesData.nameData.get(`${language}.${species}.titles`);
    if (!titleData?.titles) return null;

    const genderTitles = titleData.titles[gender];
    if (!genderTitles || genderTitles.length === 0) {
      globalNamesData._log('console.no-titles-found', { 
        gender, 
        language, 
        species 
      });
      
      if (gender === 'nonbinary' && titleData.titles.male) {
        const maleTitles = titleData.titles.male;
        const selectedTitle = maleTitles[Math.floor(Math.random() * maleTitles.length)];
        if (settlement && selectedTitle.template) {
          return this._formatTitleWithSettlement(selectedTitle, settlement, language, species);
        }
        return selectedTitle.name || selectedTitle;
      }
      return null;
    }

    const selectedTitle = genderTitles[Math.floor(Math.random() * genderTitles.length)];

    if (settlement && selectedTitle.template) {
      return this._formatTitleWithSettlement(selectedTitle, settlement, language, species);
    }

    return selectedTitle.name || selectedTitle;
  }

  _formatTitleWithSettlement(title, settlement, language, species) {
    if (!title.template) return title.name || title;

    const grammarKey = `${language}.${species}`;
    const grammarRules = globalNamesData.grammarRules.get(grammarKey);

    let article = title.preposition || 'von';

    if (grammarRules?.articles && title.preposition) {
      const prepositionRules = grammarRules.articles[title.preposition];
      if (prepositionRules) {
        const gender = settlement.gender || 'n';
        article = prepositionRules[gender] || title.preposition;
      }
    }

    return title.template
      .replace('{preposition}', article)
      .replace('{settlement}', settlement.name);
  }

  _getRandomFromData(language, species, category) {
    const key = `${language}.${species}.${category}`;
    const data = globalNamesData.nameData.get(key);

    if (!data?.names || data.names.length === 0) {
      globalNamesData._log('console.no-data-found', { key });
      return null;
    }

    return data.names[Math.floor(Math.random() * data.names.length)];
  }

  _getRandomFromGenderedData(language, species, category, gender) {
    const key = `${language}.${species}.${category}`;
    const data = globalNamesData.nameData.get(key);

    if (data?.names && typeof data.names === 'object' && data.names[gender]) {
      const genderNames = data.names[gender];
      if (genderNames.length === 0) {
        globalNamesData._log('console.no-gender-data', { 
          gender, 
          category, 
          key 
        });
        return null;
      }
      return genderNames[Math.floor(Math.random() * genderNames.length)];
    }

    if (data?.names && Array.isArray(data.names)) {
      return data.names[Math.floor(Math.random() * data.names.length)];
    }

    globalNamesData._log('console.no-data-found', { key });
    return null;
  }

  _collectAuthorCredits(language, species, components) {
    const authors = new Map();

    for (const component of components) {
      const key = `${language}.${species}.${component}`;
      const data = globalNamesData.nameData.get(key);

      if (data?.authors) {
        for (const author of data.authors) {
          const authorKey = author.name || author.email || 'Unbekannt';
          authors.set(authorKey, author);
        }
      }
    }

    if (authors.size === 0) return '';

    let creditsHtml = '<div class="names-module-author-credits"><strong>Quellen:</strong><br>';

    for (const [key, author] of authors) {
      creditsHtml += `<div class="names-module-author-entry">`;
      creditsHtml += `<span class="names-module-author-name">${author.name || 'Unbekannt'}</span>`;

      const links = [];
      if (author.email) links.push(`<a href="mailto:${author.email}" title="E-Mail">✉️</a>`);
      if (author.url) links.push(`<a href="${author.url}" target="_blank" title="Website">🌐</a>`);
      if (author.github) links.push(`<a href="${author.github}" target="_blank" title="GitHub">💻</a>`);
      if (author.twitter) links.push(`<a href="${author.twitter}" target="_blank" title="Twitter">🦐</a>`);

      if (links.length > 0) {
        creditsHtml += ` <span class="names-module-author-links">${links.join(' ')}</span>`;
      }

      creditsHtml += `</div>`;
    }

    creditsHtml += '</div>';
    return creditsHtml;
  }

  async _onCopyName(event) {
    event.preventDefault();

    const form = event.currentTarget.closest('form');
    const nameElements = form.querySelectorAll('.names-module-generated-name');
    if (nameElements.length === 0) return;

    const names = Array.from(nameElements).map(el => el.textContent).join('\n');

    try {
      await navigator.clipboard.writeText(names);
      ui.notifications.info(game.i18n.localize("names.copied"));
    } catch (error) {
      globalNamesData._log('console.clipboard-fallback');
      this._fallbackCopyToClipboard(names);
    }
  }

  _fallbackCopyToClipboard(text) {
    const textArea = document.createElement("textarea");
    textArea.value = text;
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();

    try {
      document.execCommand('copy');
      ui.notifications.info(game.i18n.localize("names.copied"));
    } catch (error) {
      ui.notifications.error(game.i18n.localize("names.copy-error"));
    }

    document.body.removeChild(textArea);
  }

  _onClearResult(event) {
    event.preventDefault();

    const form = event.currentTarget.closest('form');
    const resultDiv = form.querySelector('#names-result-display');

    resultDiv.innerHTML = `<div class="names-module-no-result">${game.i18n.localize("names.select-options")}</div>`;

    form.querySelector('#names-copy-btn').disabled = true;
    form.querySelector('#names-clear-btn').disabled = true;
  }
}

// ===== KOMPAKTER NAMEN-PICKER =====
class NamesPickerApp extends Application {
  constructor(options = {}) {
    super(options);
    this.actor = options.actor;
    this.currentNames = [];
    this.supportedGenders = ['male', 'female', 'nonbinary'];
  }

  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      id: "names-picker",
      title: game.i18n.localize("names.title"),
      template: "modules/names/templates/names-picker.hbs",
      width: 400,
      height: 350,
      resizable: false,
      classes: ["names-picker-app"]
    });
  }

  async getData() {
    ensureGlobalNamesData();
    await globalNamesData.initializeData();

    const actorSpecies = this._getActorSpecies();
    const defaultLanguage = globalNamesData.languageConfig?.defaultLanguage || 'de';

    return {
      languages: globalNamesData.getLocalizedLanguages(),
      species: globalNamesData.getLocalizedSpecies(),
      currentNames: this.currentNames,
      actorSpecies: actorSpecies,
      defaultLanguage: defaultLanguage,
      isLoading: globalNamesData.isLoading,
      isLoaded: globalNamesData.isLoaded
    };
  }

  _getActorSpecies() {
    if (!this.actor) return null;

    const actorData = this.actor.system || this.actor.data?.data || {};
    
    if (globalNamesData.speciesConfig) {
      const searchFields = globalNamesData.speciesConfig.searchFields;
      
      for (const field of searchFields) {
        const value = foundry.utils.getProperty(actorData, field);
        if (value) {
          const normalized = value.toString().toLowerCase();
          
          for (const [species, config] of Object.entries(globalNamesData.speciesConfig.speciesMappings)) {
            for (const keyword of config.keywords) {
              if (normalized.includes(keyword.toLowerCase())) {
                return species;
              }
            }
          }
        }
      }
      
      return globalNamesData.speciesConfig.defaultSpecies;
    } else {
      const raceFields = ['race', 'species', 'ancestry', 'details.race', 'details.species'];
      
      for (const field of raceFields) {
        const value = foundry.utils.getProperty(actorData, field);
        if (value) {
          const normalized = value.toString().toLowerCase();
          const raceMapping = {
            'human': 'human',
            'mensch': 'human',
            'elf': 'elf',
            'elfe': 'elf',
            'dwarf': 'dwarf',
            'zwerg': 'dwarf',
            'halfling': 'halfling',
            'halbling': 'halfling'
          };

          for (const [key, mapped] of Object.entries(raceMapping)) {
            if (normalized.includes(key)) {
              return mapped;
            }
          }
        }
      }
      
      return 'human';
    }
  }

  activateListeners(html) {
    super.activateListeners(html);

    html.find('.names-picker-generate').click(this._onGenerateNames.bind(this));
    html.find('.names-picker-name').click(this._onSelectName.bind(this));
    html.find('select').change(this._onOptionChange.bind(this));

    if (globalNamesData.isLoading) {
      this._showLoadingState(html);
      this._waitForLoadingComplete(html);
    } else {
      this._onGenerateNames();
    }
  }

  async _waitForLoadingComplete(html) {
    await globalNamesData.loadingPromise;
    
    html.find('.names-picker-loading').hide();
    html.find('.names-picker-content').show();
    
    await this._onGenerateNames();
  }

  _showLoadingState(html) {
    html.find('.names-picker-content').hide();
    
    if (!html.find('.names-picker-loading').length) {
      html.find('.window-content').prepend(`
        <div class="names-picker-loading" style="text-align: center; padding: 50px;">
          <i class="fas fa-spinner fa-spin" style="font-size: 2em; color: #ff6400;"></i>
          <p style="margin-top: 15px;">${game.i18n.localize("names.loading-data") || "Lade Namen-Daten..."}</p>
        </div>
      `);
    }
  }

  _onOptionChange(event) {
    this._onGenerateNames();
  }

  async _onGenerateNames() {
    const html = this.element;
    const language = html.find('#picker-language').val() || 
                    globalNamesData.languageConfig?.defaultLanguage || 'de';
    const species = html.find('#picker-species').val() || this._getActorSpecies() || 'human';
    const category = html.find('#picker-category').val() || 'male';

    try {
      const names = [];
      for (let i = 0; i < 3; i++) {
        let name;
        if (this.supportedGenders.includes(category)) {
          name = await this._generateFormattedName(
            language, species, category, 
            ['firstname', 'surname'], 
            '{firstname} {surname}'
          );
        } else {
          name = await this._generateSimpleName(language, species, category);
        }
        
        if (name) {
          names.push(name);
        }
      }

      this.currentNames = names;

      const namesList = html.find('.names-picker-list');
      namesList.empty();

      for (const name of names) {
        namesList.append(`
          <div class="names-picker-name" data-name="${name}">
            <i class="fas fa-user"></i>
            ${name}
          </div>
        `);
      }

      html.find('.names-picker-name').click(this._onSelectName.bind(this));

    } catch (error) {
      globalNamesData._log('console.generation-error', null, error);
      ui.notifications.error(game.i18n.localize("names.generation-error"));
    }
  }

  // Verwende die gleichen Methoden wie NamesGeneratorApp
  async _generateFormattedName(language, species, gender, components, nameFormat) {
    const nameComponents = {};
    for (const component of components) {
      try {
        let part = await this._generateNameComponent(language, species, gender, component);
        if (part) {
          nameComponents[component] = part;
        }
      } catch (error) {
        globalNamesData._log('console.component-generation-failed', { component }, error);
      }
    }

    if (Object.keys(nameComponents).length === 0) {
      throw new Error(game.i18n.localize("names.no-names-generated"));
    }

    return this._formatName(nameFormat, nameComponents);
  }

  async _generateSimpleName(language, species, category) {
    if (category === 'settlements') {
      const settlementData = globalNamesData.nameData.get(`${language}.${species}.settlements`);
      if (!settlementData?.settlements) {
        throw new Error(`Keine Siedlungsdaten für ${language}.${species}`);
      }
      const settlements = settlementData.settlements;
      const settlement = settlements[Math.floor(Math.random() * settlements.length)];
      return settlement.name || settlement;
    } else {
      return this._getRandomFromData(language, species, category);
    }
  }

  async _generateNameComponent(language, species, gender, component) {
    switch (component) {
      case 'firstname':
        return this._getRandomFromData(language, species, gender);

      case 'surname':
        return this._getRandomFromData(language, species, 'surnames');

      default:
        return null;
    }
  }

  _formatName(format, components) {
    let result = format;

    const placeholders = {
      '{firstname}': components.firstname || '',
      '{surname}': components.surname || ''
    };

    for (const [placeholder, value] of Object.entries(placeholders)) {
      result = result.replace(new RegExp(placeholder.replace(/[{}]/g, '\\$&'), 'g'), value);
    }

    return result.replace(/\s+/g, ' ').trim();
  }

  _getRandomFromData(language, species, category) {
    const key = `${language}.${species}.${category}`;
    const data = globalNamesData.nameData.get(key);

    if (!data?.names || data.names.length === 0) {
      globalNamesData._log('console.no-data-found', { key });
      return null;
    }

    return data.names[Math.floor(Math.random() * data.names.length)];
  }

  async _onSelectName(event) {
    const selectedName = event.currentTarget.dataset.name;
    if (!selectedName || !this.actor) return;

    try {
      await this._updateActorName(selectedName);
      const message = game.i18n.format("names.name-adopted", { name: selectedName });
      ui.notifications.info(message);
      this.close();

    } catch (error) {
      globalNamesData._log('console.name-setting-error', null, error);
      ui.notifications.error(game.i18n.localize("names.name-error"));
    }
  }

  async _updateActorName(name) {
    if (!this.actor) return;

    await this.actor.update({ name: name });

    const tokens = canvas.tokens.placeables.filter(t => t.actor?.id === this.actor.id);
    for (const token of tokens) {
      await token.document.update({ name: name });
    }

    if (this.actor.prototypeToken) {
      await this.actor.update({
        "prototypeToken.name": name
      });
    }
  }
}

// ===== VERBESSERTE EMERGENCY NPC NAMES APP =====
class EmergencyNamesApp extends Application {
  constructor(options = {}) {
    super(options);
    this.emergencyNames = [];
    this.availableSpecies = ['human', 'elf', 'dwarf', 'halfling', 'orc'];
  }

  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      id: "emergency-names",
      title: game.i18n.localize("names.emergency.title") || "Schnelle NPC Namen",
      template: "modules/names/templates/emergency-names.hbs",
      width: 500,
      height: 400,
      resizable: false,
      classes: ["emergency-names-app"]
    });
  }

  async getData() {
    // Prüfe ob globalNamesData existiert, falls nicht erstelle eine Fallback-Instanz
    if (typeof globalNamesData === 'undefined' || globalNamesData === null) {
      console.warn("Names Module: globalNamesData not available, creating temporary instance");
      // Erstelle temporäre Instanz falls die globale noch nicht existiert
      globalNamesData = new NamesDataManager();
    }

    // Stelle sicher, dass die Daten geladen sind
    try {
      if (globalNamesData && typeof globalNamesData.initializeData === 'function') {
        await globalNamesData.initializeData();
      }
    } catch (error) {
      console.warn("Names Module: Failed to initialize data:", error);
    }

    return {
      emergencyNames: this.emergencyNames,
      isLoading: globalNamesData?.isLoading || false
    };
  }

  activateListeners(html) {
    super.activateListeners(html);

    // Event-Handler mit besserer Error-Behandlung
    html.find('.emergency-reroll-btn').off('click').on('click', this._onRerollNames.bind(this));
    html.find('.emergency-open-generator-btn').off('click').on('click', this._onOpenGenerator.bind(this));
    html.find('.emergency-name-item').off('click').on('click', this._onCopyName.bind(this));

    // Initialisierung mit verbesserter Logik
    this._initializeApp(html);
  }

  async _initializeApp(html) {
    try {
      // Stelle sicher, dass globalNamesData verfügbar ist
      this._ensureGlobalNamesData();
      
      if (globalNamesData && globalNamesData.isLoading) {
        this._showLoadingState(html);
        await this._waitForLoadingComplete(html);
      } else {
        await this._generateEmergencyNames();
      }
    } catch (error) {
      console.error("Names Module: Emergency app initialization failed:", error);
      // Fallback zu statischen Namen wenn alles fehlschlägt
      this._generateFallbackNames();
      this._updateNamesDisplay();
    }
  }

  _ensureGlobalNamesData() {
    if (typeof globalNamesData === 'undefined' || globalNamesData === null) {
      console.warn("Names Module: Creating fallback NamesDataManager instance");
      globalNamesData = new NamesDataManager();
    }
  }

  async _waitForLoadingComplete(html) {
    try {
      if (globalNamesData && globalNamesData.loadingPromise) {
        await globalNamesData.loadingPromise;
      }
      
      html.find('.emergency-loading').hide();
      html.find('.emergency-content').show();
      
      await this._generateEmergencyNames();
    } catch (error) {
      console.warn("Names Module: Loading failed, using fallback:", error);
      this._generateFallbackNames();
      this._updateNamesDisplay();
    }
  }

  _showLoadingState(html) {
    html.find('.emergency-content').hide();
    
    if (!html.find('.emergency-loading').length) {
      html.find('.window-content').prepend(`
        <div class="emergency-loading" style="text-align: center; padding: 50px;">
          <i class="fas fa-spinner fa-spin" style="font-size: 2em; color: #ff6400;"></i>
          <p style="margin-top: 15px;">${game.i18n.localize("names.loading-data") || "Lade Namen-Daten..."}</p>
        </div>
      `);
    }
  }

  async _generateEmergencyNames() {
    console.log("Names Module: Generating emergency names...");
    
    try {
      const language = this._getFoundryLanguage();
      console.log("Names Module: Using language:", language);
      
      const names = [];
      
      // Prüfe ob globalNamesData verfügbar und geladen ist
      if (!globalNamesData || !globalNamesData.isLoaded) {
        console.warn("Names Module: Data not loaded, using fallback names");
        this._generateFallbackNames();
        return;
      }

      // Bestimme verfügbare Spezies basierend auf geladenen Daten
      const availableSpecies = this._getAvailableSpecies(language);
      console.log("Names Module: Available species:", availableSpecies);
      
      if (availableSpecies.length === 0) {
        console.warn("Names Module: No species data available, using fallback");
        this._generateFallbackNames();
        return;
      }
      
      for (let i = 0; i < 5; i++) {
        try {
          const species = availableSpecies[Math.floor(Math.random() * availableSpecies.length)];
          const gender = this._getRandomGender();
          
          const name = await this._generateSingleName(language, species, gender);
          if (name) {
            names.push({
              name: name,
              species: species,
              gender: gender,
              displaySpecies: this._getLocalizedSpecies(species)
            });
          }
        } catch (error) {
          console.warn(`Names Module: Failed to generate name ${i}:`, error);
        }
      }

      // Fallback falls keine Namen generiert werden konnten
      if (names.length === 0) {
        console.warn("Names Module: No names generated, using fallback");
        this._generateFallbackNames();
      } else {
        this.emergencyNames = names;
        console.log("Names Module: Generated", names.length, "emergency names");
        this._updateNamesDisplay();
      }

    } catch (error) {
      console.error("Names Module: Emergency name generation failed:", error);
      this._generateFallbackNames();
    }
  }

  _generateFallbackNames() {
    console.log("Names Module: Using fallback emergency names");
    this.emergencyNames = [
      { name: "Alaric Steinherz", species: "human", gender: "male", displaySpecies: "Mensch" },
      { name: "Lyra Mondschein", species: "elf", gender: "female", displaySpecies: "Elf" },
      { name: "Thorin Eisenfaust", species: "dwarf", gender: "male", displaySpecies: "Zwerg" },
      { name: "Rosie Hügelkind", species: "halfling", gender: "female", displaySpecies: "Halbling" },
      { name: "Grimjaw der Wilde", species: "orc", gender: "male", displaySpecies: "Ork" }
    ];
    this._updateNamesDisplay();
  }

  _getFoundryLanguage() {
    // Verwende Foundry's aktuelle Sprache, falle zurück auf 'de'
    const foundryLang = game.settings.get("core", "language");
    
    // Mappe Foundry Sprachen auf unsere Sprach-Codes
    const languageMapping = {
      'en': 'en',
      'de': 'de',
      'fr': 'fr',
      'es': 'es',
      'it': 'it'
    };

    const mappedLang = languageMapping[foundryLang] || 'de';
    console.log("Names Module: Foundry lang:", foundryLang, "mapped to:", mappedLang);
    
    // Prüfe ob die Sprache verfügbar ist
    if (globalNamesData && globalNamesData.availableLanguages && globalNamesData.availableLanguages.has(mappedLang)) {
      return mappedLang;
    }
    
    // Fallback zur ersten verfügbaren Sprache oder 'de'
    if (globalNamesData && globalNamesData.availableLanguages && globalNamesData.availableLanguages.size > 0) {
      const firstLang = Array.from(globalNamesData.availableLanguages)[0];
      console.log("Names Module: Using first available language:", firstLang);
      return firstLang;
    }
    
    return 'de';
  }

  _getAvailableSpecies(language) {
    const speciesWithData = new Set();
    
    // Sammle alle Spezies die für diese Sprache Daten haben
    if (globalNamesData && globalNamesData.nameData) {
      for (const [key, data] of globalNamesData.nameData.entries()) {
        const [dataLang, dataSpecies, dataCategory] = key.split('.');
        if (dataLang === language && (dataCategory === 'male' || dataCategory === 'female')) {
          speciesWithData.add(dataSpecies);
        }
      }
    }
    
    const result = Array.from(speciesWithData).length > 0 ? 
           Array.from(speciesWithData) : 
           ['human', 'elf', 'dwarf'];
           
    console.log("Names Module: Species with data for", language, ":", result);
    return result;
  }

  _getRandomGender() {
    const genders = ['male', 'female'];
    return genders[Math.floor(Math.random() * genders.length)];
  }

  async _generateSingleName(language, species, gender) {
    try {
      // Versuche einen Vollnamen zu generieren
      const firstName = this._getRandomFromData(language, species, gender);
      const lastName = this._getRandomFromData(language, species, 'surnames');
      
      if (firstName && lastName) {
        return `${firstName} ${lastName}`;
      } else if (firstName) {
        return firstName;
      }
      
      return null;
    } catch (error) {
      console.warn(`Names Module: Failed to generate name for ${language}.${species}.${gender}:`, error);
      return null;
    }
  }

  _getRandomFromData(language, species, category) {
    if (!globalNamesData || !globalNamesData.nameData) {
      return null;
    }

    const key = `${language}.${species}.${category}`;
    const data = globalNamesData.nameData.get(key);

    if (!data?.names || data.names.length === 0) {
      console.warn(`Names Module: No data found for key: ${key}`);
      return null;
    }

    return data.names[Math.floor(Math.random() * data.names.length)];
  }

  _getLocalizedSpecies(species) {
    const locKey = `names.species.${species}`;
    return game.i18n.localize(locKey) || species.charAt(0).toUpperCase() + species.slice(1);
  }

  _updateNamesDisplay() {
    const html = this.element;
    if (!html || html.length === 0) {
      console.warn("Names Module: Cannot update display - element not found");
      return;
    }
    
    const container = html.find('.emergency-names-list');
    if (container.length === 0) {
      console.warn("Names Module: Cannot find emergency names list container");
      return;
    }
    
    console.log("Names Module: Updating display with", this.emergencyNames.length, "names");
    
    container.empty();
    
    for (const nameData of this.emergencyNames) {
      const nameElement = $(`
        <div class="emergency-name-item" data-name="${nameData.name}" title="${game.i18n.localize("names.emergency.clickToCopy") || "Klicken zum Kopieren"}">
          <span class="emergency-name">${nameData.name}</span>
          <span class="emergency-species">${nameData.displaySpecies}</span>
        </div>
      `);
      
      container.append(nameElement);
    }
    
    // Event-Listener für die neuen Elemente neu binden
    html.find('.emergency-name-item').off('click').on('click', this._onCopyName.bind(this));
  }

  async _onRerollNames(event) {
    console.log("Names Module: Reroll button clicked");
    event.preventDefault();
    
    const html = this.element;
    const rerollBtn = html.find('.emergency-reroll-btn');
    
    // Zeige Loading-State
    rerollBtn.prop('disabled', true);
    rerollBtn.html('<i class="fas fa-spinner fa-spin"></i> ' + (game.i18n.localize("names.emergency.generating") || "Generiere..."));
    
    try {
      await this._generateEmergencyNames();
    } catch (error) {
      console.error("Names Module: Reroll failed:", error);
      ui.notifications.error("Fehler beim Generieren der Namen");
    } finally {
      // Verstecke Loading-State
      rerollBtn.prop('disabled', false);
      rerollBtn.html('<i class="fas fa-dice"></i> ' + (game.i18n.localize("names.emergency.reroll") || "Neue Namen"));
    }
  }

  _onOpenGenerator() {
    console.log("Names Module: Opening main generator");
    new NamesGeneratorApp().render(true);
    this.close();
  }

  async _onCopyName(event) {
    console.log("Names Module: Copy name clicked");
    event.preventDefault();
    
    const nameElement = $(event.currentTarget);
    const name = nameElement.data('name');
    
    if (!name) {
      console.warn("Names Module: No name data found");
      return;
    }

    try {
      await navigator.clipboard.writeText(name);
      
      // Visuelles Feedback
      nameElement.addClass('copied');
      setTimeout(() => nameElement.removeClass('copied'), 1000);
      
      ui.notifications.info(game.i18n.format("names.emergency.nameCopied", { name: name }) || `Name "${name}" kopiert`);
    } catch (error) {
      console.warn("Names Module: Clipboard API failed, using fallback:", error);
      // Fallback für ältere Browser
      this._fallbackCopyToClipboard(name);
    }
  }

  _fallbackCopyToClipboard(text) {
    const textArea = document.createElement("textarea");
    textArea.value = text;
    textArea.style.position = "fixed";
    textArea.style.top = "-9999px";
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();

    try {
      document.execCommand('copy');
      ui.notifications.info(game.i18n.format("names.emergency.nameCopied", { name: text }) || `Name "${text}" kopiert`);
    } catch (error) {
      console.error("Names Module: Fallback copy failed:", error);
      ui.notifications.error(game.i18n.localize("names.copy-error") || "Kopieren fehlgeschlagen");
    }

    document.body.removeChild(textArea);
  }
}

// ===== VERBESSERTE CHAT BUTTON INJECTION =====
function injectEmergencyButton() {
  // Prüfe Settings
  if (!game.settings.get("names", "showEmergencyButton")) {
    removeEmergencyButton();
    return;
  }

  // Prüfe ob Button bereits existiert
  if ($('#emergency-names-button').length > 0) {
    return;
  }

  // Finde das Chat-Log und Chat-Form
  const chatLog = $('#chat-log');
  const chatForm = $('#chat-form');
  
  if (chatLog.length === 0 || chatForm.length === 0) {
    return;
  }

  // Erstelle den Button
  const emergencyButton = $(`
    <div id="emergency-names-button" class="emergency-names-chat-button" title="${game.i18n.localize("names.emergency.tooltip") || "Schnelle NPC-Namen"}">
      <i class="fas fa-user-friends"></i>
      <span>${game.i18n.localize("names.emergency.button") || "NPC Namen"}</span>
    </div>
  `);

  // Event-Listener mit verbesserter Fehlerbehandlung
  emergencyButton.click(() => {
    try {
      if (hasNamesGeneratorPermission()) {
        // Stelle sicher, dass die NamesDataManager-Klasse verfügbar ist
        if (typeof NamesDataManager === 'undefined') {
          ui.notifications.error("Namen-Generator nicht verfügbar. Module noch nicht geladen.");
          return;
        }
        
        console.log("Names Module: Opening Emergency Names App");
        new EmergencyNamesApp().render(true);
      } else {
        ui.notifications.warn(game.i18n.localize("names.no-permission") || "Keine Berechtigung");
      }
    } catch (error) {
      console.error("Names Module: Failed to open Emergency Names App:", error);
      ui.notifications.error("Fehler beim Öffnen des Namen-Generators");
    }
  });

  // Button zwischen Chat-Log und Chat-Form einfügen
  chatLog.after(emergencyButton);
  
  // CSS für den Button hinzufügen
  if (!$('#emergency-names-button-style').length) {
    $('head').append(`
      <style id="emergency-names-button-style">
        #emergency-names-button, .emergency-names-chat-button {
          background: linear-gradient(135deg, #ff6400 0%, #ff8533 100%);
          border: 1px solid #e55a00;
          border-radius: 6px;
          color: white;
          padding: 8px 16px;
          margin: 10px;
          cursor: pointer;
          font-weight: bold;
          font-size: 12px;
          display: flex;
          align-items: center;
          gap: 6px;
          transition: all 0.2s ease;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        #emergency-names-button:hover, .emergency-names-chat-button:hover {
          background: linear-gradient(135deg, #ff8533 0%, #ffaa66 100%);
          box-shadow: 0 4px 8px rgba(255, 100, 0, 0.3);
          transform: translateY(-1px);
        }
        
        #emergency-names-button:active, .emergency-names-chat-button:active {
          transform: translateY(0);
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        #emergency-names-button i, .emergency-names-chat-button i {
          font-size: 14px;
        }
      </style>
    `);
  }
  
  console.log("Names Module: Emergency button injected");
}

function removeEmergencyButton() {
  $('#emergency-names-button').remove();
  console.log("Names Module: Emergency button removed");
}

// Verbesserte hasNamesGeneratorPermission Funktion mit Fehlerbehandlung
function hasNamesGeneratorPermission() {
  try {
    const allowedRoles = game.settings.get("names", "allowedUserRoles") || [CONST.USER_ROLES.GAMEMASTER];
    const userRole = game.user.role;
    
    return allowedRoles.includes(userRole);
  } catch (error) {
    console.warn("Names Module: Permission check failed, defaulting to GM only:", error);
    return game.user.role === CONST.USER_ROLES.GAMEMASTER;
  }
}

class NamesRoleConfig extends FormApplication {
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      id: "names-role-config",
      title: game.i18n.localize("names.roleConfig.title"),
      template: "modules/names/templates/role-config.hbs",
      width: 620,
      height: 550,
      closeOnSubmit: true,
      resizable: false
    });
  }

  getData() {
    const currentRoles = game.settings.get("names", "allowedUserRoles");
    const allRoles = [
      { level: CONST.USER_ROLES.PLAYER, name: "PLAYER", key: "PLAYER" },
      { level: CONST.USER_ROLES.TRUSTED, name: "TRUSTED", key: "TRUSTED" },
      { level: CONST.USER_ROLES.ASSISTANT, name: "ASSISTANT", key: "ASSISTANT" },
      { level: CONST.USER_ROLES.GAMEMASTER, name: "GAMEMASTER", key: "GAMEMASTER" }
    ];

    return {
      roles: allRoles.map(role => ({
        ...role,
        checked: currentRoles.includes(role.level) || role.level === CONST.USER_ROLES.GAMEMASTER
      }))
    };
  }

  activateListeners(html) {
    super.activateListeners(html);

    html.find('.role-toggle').click((event) => {
      const toggle = $(event.currentTarget);
      const checkbox = toggle.find('input[type="checkbox"]');
      
      if (toggle.hasClass('locked')) {
        return;
      }
      
      const wasChecked = checkbox.prop('checked');
      checkbox.prop('checked', !wasChecked);
      
      if (!wasChecked) {
        toggle.addClass('active');
      } else {
        toggle.removeClass('active');
      }
      
      event.preventDefault();
    });

    html.find('input[type="checkbox"]').click((event) => {
      event.stopPropagation();
      const checkbox = $(event.currentTarget);
      const toggle = checkbox.closest('.role-toggle');
      
      if (checkbox.prop('disabled')) {
        return;
      }
      
      if (checkbox.prop('checked')) {
        toggle.addClass('active');
      } else {
        toggle.removeClass('active');
      }
    });

    html.find('button[name="reset"]').click((event) => {
      event.preventDefault();
      const defaultRoles = [CONST.USER_ROLES.GAMEMASTER];
      
      html.find('.role-toggle').each((i, toggle) => {
        const $toggle = $(toggle);
        const checkbox = $toggle.find('input[type="checkbox"]');
        const level = parseInt(checkbox.attr('name').replace('role_', ''));
        
        if (defaultRoles.includes(level)) {
          checkbox.prop('checked', true);
          $toggle.addClass('active');
        } else if (!$toggle.hasClass('locked')) {
          checkbox.prop('checked', false);
          $toggle.removeClass('active');
        }
      });
    });
  }

  async _updateObject(event, formData) {
    const oldRoles = game.settings.get("names", "allowedUserRoles");
    const newAllowedRoles = [CONST.USER_ROLES.GAMEMASTER];
    
    for (const [key, value] of Object.entries(formData)) {
      if (key.startsWith('role_') && value) {
        const roleLevel = parseInt(key.replace('role_', ''));
        if (!newAllowedRoles.includes(roleLevel)) {
          newAllowedRoles.push(roleLevel);
        }
      }
    }

    await game.settings.set("names", "allowedUserRoles", newAllowedRoles);
    ui.notifications.info(game.i18n.localize("names.permissions-saved"));
    
    const affectedUsers = this._getAffectedUsers(oldRoles, newAllowedRoles);
    
    if (affectedUsers.length > 0) {
      game.socket.emit("module.names", {
        type: "permissionChanged",
        affectedUsers: affectedUsers
      });
    }
  }

  _getAffectedUsers(oldRoles, newRoles) {
    const affectedUsers = [];
    
    for (const user of game.users) {
      const hadPermission = oldRoles.includes(user.role);
      const hasPermission = newRoles.includes(user.role);
      
      if (hadPermission !== hasPermission) {
        affectedUsers.push(user.id);
      }
    }
    
    return affectedUsers;
  }
}

// ===== MODULE INITIALIZATION =====
Hooks.once('init', () => {
  console.log(game.i18n.localize("names.console.module-init") || "Names Module: Initialisiere...");

  // Globale Instanz erstellen mit Schutz
  try {
    globalNamesData = new NamesDataManager();
    console.log("Names Module: NamesDataManager created successfully");
  } catch (error) {
    console.error("Names Module: Failed to create NamesDataManager:", error);
  }

  game.settings.register("names", "showInTokenControls", {
    name: game.i18n.localize("names.settings.showInTokenControls.name"),
    hint: game.i18n.localize("names.settings.showInTokenControls.hint"),
    scope: "world",
    config: true,
    type: Boolean,
    default: true
  });

  game.settings.register("names", "showInCharacterSheet", {
    name: game.i18n.localize("names.settings.showInCharacterSheet.name"),
    hint: game.i18n.localize("names.settings.showInCharacterSheet.hint"),
    scope: "world",
    config: true,
    type: Boolean,
    default: true
  });

  game.settings.register("names", "showInTokenContextMenu", {
    name: game.i18n.localize("names.settings.showInTokenContextMenu.name"),
    hint: game.i18n.localize("names.settings.showInTokenContextMenu.hint"),
    scope: "world",
    config: true,
    type: Boolean,
    default: true
  });

  game.settings.register("names", "showEmergencyButton", {
    name: game.i18n.localize("names.settings.showEmergencyButton.name") || "Emergency Button anzeigen",
    hint: game.i18n.localize("names.settings.showEmergencyButton.hint") || "Zeigt einen Emergency Button im Chat an",
    scope: "world",
    config: true,
    type: Boolean,
    default: true,
    onChange: (value) => {
      // Button sofort ein-/ausblenden bei Setting-Änderung
      if (value && hasNamesGeneratorPermission()) {
        setTimeout(() => injectEmergencyButton(), 100);
      } else {
        removeEmergencyButton();
      }
    }
  });

  game.settings.register("names", "allowedUserRoles", {
    name: "Erlaubte Benutzerrollen",
    hint: "Welche Benutzerrollen dürfen den Namen-Generator verwenden",
    scope: "world",
    config: false,
    type: Array,
    default: [CONST.USER_ROLES.GAMEMASTER]
  });

  game.settings.registerMenu("names", "roleConfig", {
    name: game.i18n.localize("names.settings.roleConfig.name"),
    hint: game.i18n.localize("names.settings.roleConfig.hint"),
    label: game.i18n.localize("names.settings.roleConfig.label"),
    icon: "fas fa-users-cog",
    type: NamesRoleConfig,
    restricted: true
  });

  game.socket.on("module.names", (data) => {
    if (data.type === "permissionChanged" && data.affectedUsers.includes(game.user.id)) {
      new Dialog({
        title: game.i18n.localize("names.permissionChange.title") || "Berechtigung geändert",
        content: `
          <div style="text-align: center; padding: 20px;">
            <i class="fas fa-exclamation-triangle" style="font-size: 2em; color: #ff6400; margin-bottom: 15px;"></i>
            <p>${game.i18n.localize("names.permissionChange.content") || "Deine Namen-Generator Berechtigung wurde vom Spielleiter geändert. Ein Reload der Seite ist erforderlich, damit die Änderungen wirksam werden."}</p>
          </div>
        `,
        buttons: {
          reload: {
            icon: '<i class="fas fa-sync-alt"></i>',
            label: game.i18n.localize("names.permissionChange.reload") || "Seite neu laden",
            callback: () => location.reload()
          },
          later: {
            icon: '<i class="fas fa-clock"></i>',
            label: game.i18n.localize("names.permissionChange.later") || "Später",
            callback: () => {}
          }
        },
        default: "reload"
      }, {
        width: 400,
        height: 200
      }).render(true);
    }
  });
});

// Background Loading nach Foundry Init
Hooks.once('ready', () => {
  console.log("Names Module: Ready hook - initializing data");
  
  // Stelle sicher dass globalNamesData existiert
  ensureGlobalNamesData();
  
  if (globalNamesData) {
    globalNamesData.initializeData();
  }
  
  // Emergency Button nach kurzer Verzögerung hinzufügen (nur wenn aktiviert)
  setTimeout(() => {
    if (hasNamesGeneratorPermission() && game.settings.get("names", "showEmergencyButton")) {
      injectEmergencyButton();
    }
  }, 1000);
});

// Emergency Button nach Chat-Render hinzufügen
Hooks.on('renderChatLog', () => {
  setTimeout(() => {
    if (hasNamesGeneratorPermission() && game.settings.get("names", "showEmergencyButton")) {
      injectEmergencyButton();
    }
  }, 100);
});

// Token Controls
Hooks.on('getSceneControlButtons', (controls) => {
  if (!game.settings.get("names", "showInTokenControls")) return;
  if (!hasNamesGeneratorPermission()) return;

  const token = controls.find(c => c.name === 'token');
  if (!token) return;

  if (token.tools.some(t => t.name === 'names-generator')) return;

  token.tools.push({
    name: 'names-generator',
    title: game.i18n.localize("names.title"),
    icon: 'fas fa-user-tag',
    button: true,
    visible: () => hasNamesGeneratorPermission(),
    onClick: () => new NamesGeneratorApp().render(true)
  });
});

// Character Sheet Integration
Hooks.on('renderActorSheet', (app, html, data) => {
  if (!game.settings.get("names", "showInCharacterSheet")) return;
  if (!hasNamesGeneratorPermission()) return;
  if (app.actor.type !== 'character') return;

  const nameInput = html.find('input[name="name"]');
  if (nameInput.length > 0) {
    const button = $(`
      <button type="button" class="names-picker-button" title="${game.i18n.localize("names.choose-name")}">
        <i class="fas fa-dice"></i>
      </button>
    `);

    nameInput.after(button);

    button.click(() => {
      new NamesPickerApp({ actor: app.actor }).render(true);
    });

    if (!$('#names-picker-button-style').length) {
      $('head').append(`
        <style id="names-picker-button-style">
          .names-picker-button {
            background: #ff6400;
            border: 1px solid #e55a00;
            border-radius: 3px;
            color: white;
            padding: 2px 8px;
            margin-left: 5px;
            cursor: pointer;
            font-size: 12px;
            height: fit-content;
          }
          .names-picker-button:hover {
            background: #ff8533;
            box-shadow: 0 0 5px rgba(255, 100, 0, 0.3);
          }
        </style>
      `);
    }
  }
});

// Token Context Menu
Hooks.on('getTokenContextOptions', (html, options) => {
  if (!game.settings.get("names", "showInTokenContextMenu")) return;
  if (!hasNamesGeneratorPermission()) return;

  options.push({
    name: game.i18n.localize("names.title"),
    icon: '<i class="fas fa-user-tag"></i>',
    condition: (token) => {
      return token.actor && hasNamesGeneratorPermission();
    },
    callback: (token) => {
      new NamesPickerApp({ actor: token.actor }).render(true);
    }
  });
});

// Token HUD
Hooks.on('renderTokenHUD', (app, html, data) => {
  if (!game.settings.get("names", "showInTokenContextMenu")) return;
  if (!hasNamesGeneratorPermission()) return;
  if (!app.object?.actor) return;

  const button = $(`
    <div class="control-icon" title="${game.i18n.localize("names.title")}">
      <i class="fas fa-user-tag"></i>
    </div>
  `);

  button.click(() => {
    new NamesPickerApp({ actor: app.object.actor }).render(true);
  });

  html.find('.left').append(button);
});

// Chat Commands
Hooks.on('chatMessage', (html, content, msg) => {
  if (!hasNamesGeneratorPermission()) {
    if (content === '/names' || content === '/namen' || content === '/pick-name' || content === '/name-picker' || content === '/emergency-names') {
      ui.notifications.warn(game.i18n.localize("names.no-permission"));
      return false;
    }
    return;
  }

  if (content === '/names' || content === '/namen') {
    new NamesGeneratorApp().render(true);
    return false;
  }

  if (content === '/pick-name' || content === '/name-picker') {
    const controlled = canvas.tokens.controlled;
    if (controlled.length === 1 && controlled[0].actor) {
      new NamesPickerApp({ actor: controlled[0].actor }).render(true);
    } else {
      ui.notifications.warn(game.i18n.localize("names.select-one-token"));
    }
    return false;
  }

  if (content === '/emergency-names' || content === '/npc-names') {
    new EmergencyNamesApp().render(true);
    return false;
  }
});